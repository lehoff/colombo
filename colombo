#!/usr/local/bin/escript
%%% -*- erlang -*-

-compile(export_all).

config_file() -> "./.colombo/config".

get_repo(RepoUrl) ->
    RepoName = repo_name(RepoUrl),
    case filelib:is_dir(RepoName) of
        false ->
            Cmd = io_lib:format("git clone ~s", [RepoUrl]),
            io:format("Executing: ~s~n", [Cmd]),
            os:cmd(Cmd);
        true ->
            os:cmd("cd " ++ RepoName),
            Cmd = "git pull",
            io:format("Executing: ~s in ~s~n", [Cmd, RepoName]),
            os:cmd(Cmd),
            os:cmd("cd ..")
    end.

main(["show-config"]) ->
    ConfigFile = config_file(),
    case filelib:is_file(ConfigFile) of
        true ->
            {ok, Bin} = file:read_file(ConfigFile),
            io:format("~s~n", [Bin]);
        false ->
            io:format("No config created - use 'colombo init' to create one~n", [])
    end;
main(["init"]) ->
    ConfigFile = config_file(),
    filelib:ensure_dir(ConfigFile),
    %% @todo add checking for existing config file.
    {ok, File} = file:open(ConfigFile, [write]),
    ok = file:close(File);
main(["add-repo", Repo]) ->
    RepoMap = repo_map(),
    RepoName = repo_name(Repo),
    case lists:keyfind(Repo, 1, RepoMap) of
        {Repo, ExistingUrl} ->
            io:format("Application ~s is already added as ~s~n",
                      [RepoName, ExistingUrl]);
        false ->
            ConfigFile = config_file(),
            {ok, File} = file:open(ConfigFile, [append]),
            ok = append_repo(File, Repo),
            ok = file:close(File),
            io:format("Added ~s~n", [Repo])
    end;
main(["get-repos"]) ->
    Repos = config_repos(url),
    io:format("get-repos with Repos=~p~n", [Repos]),
    _ = [ get_repo(R)  || R <- Repos];
main(["rebar-deps", RebarConfig]) ->
    Repos = rebar_deps(RebarConfig),
    [ io:format("~s~n", [Repo]) || Repo <- Repos ];
main(["get-deps"]) ->
    io:format("preparing to resolve depedencies by doing 'get-repos'~n", []),
    main(["get-repos"]),
    DepMap = dependency_map(),
    RepoMap = repo_map(),
    Missing = orddict:fetch_keys(DepMap) -- orddict:fetch_keys(RepoMap),
    case Missing of
        [] ->
            ok;
        _ ->
            io:format("Missing: ~p~n", [Missing]),
            [ main(["add-repo", orddict:fetch(M, DepMap)])
              || M <- Missing ],
            main(["get-repos"]),
            main(["get-deps"])
    end;
main(["app-deps", RepoName]) ->
    case app_dependencies(RepoName) of
        [] ->
            io:format("~s has no dependencies.~n", [RepoName]);
        Repos ->
            DepNames =
                case [repo_name(Url) || {repo, Url} <- Repos] of
                    [] ->
                        Repos;
                    List ->
                        List
                end,
            DepStr = string:join(DepNames, ", "),
            io:format("~s depends on: ~s~n", [RepoName, DepStr])
    end.

append_repo(File, Repo) ->
    file:write(File, io_lib:format("{repo, \"~s\"}.~n", [Repo])).

-spec config_repos('url'|'name') -> [string()].
config_repos(url) ->
    ConfigFile = config_file(),
    {ok, Terms} = file:consult(ConfigFile),
    %%    io:format("config_repos Terms=~p~n", [Terms]),
    [R || {repo,R} <- Terms];
config_repos(name) ->
    Urls = config_repos(url),
    [ repo_name(Url) || Url <- Urls].

rebar_deps(RebarConfig) ->
    {ok, Terms} = file:consult(RebarConfig),
%%    io:format("rebar_deps Terms=~p~n", [Terms]),
    RebarDeps = proplists:get_value(deps, Terms, []),
    [Repo || {_, _, {git, Repo, _}} <- RebarDeps].


repo_names() ->
    RepoUrls = config_repos(url),
    [ repo_name(RepoUrl) || RepoUrl <- RepoUrls].

repo_name(Url) ->
    Last = lists:last(string:tokens(Url, "/")),
    [RepoName | _ ] = string:tokens(Last, "."),
    RepoName.
    
-spec dependencies('url'|'name') -> [string()].
dependencies(url) ->
    RepoNames = repo_names(),
%%    io:format("RepoNames: ~p~n", [RepoNames]),
    Sorted =
        lists:sort(lists:flatten([app_dependencies(RepoName)
                                  || RepoName <- RepoNames])),
    [ Dep || {repo, Dep} <- Sorted ];
dependencies(name) ->
    Urls = dependencies(url),
    [ repo_name(Url) || Url <- Urls].

app_dependencies(RepoName) ->
    RepoPath = "./" ++ RepoName ++ "/",
    RebarConfig =   (RepoPath  ++ "rebar.config"),
    case filelib:is_file(RebarConfig) of
        true ->
            RebarDeps = rebar_deps(RebarConfig),
            [ {repo, D} || D <- RebarDeps ];
        false ->
            AppFile = (RepoPath ++ "ebin/" ++ RepoName ++ ".app"),
            AppSrcFile = (RepoPath ++ "src/" ++ RepoName ++ ".app.src"),
            File =
                case {filelib:is_file(AppFile), filelib:is_file(AppSrcFile)} of
                    {true, true} ->
                        io:format("ERROR: both .app and .app.src exists for ~s "
                                  ++ "- please resolve this~n",
                                  [RepoName]),
                        exit(two_app_files);
                    {true, false} ->
                        AppFile;
                    {false, true} ->
                        AppSrcFile;
                    {false, false} ->
                        io:format("ERROR: neither .app or .app.src exists for ~s "
                                  ++ "- please resolve this~n")
                end,
            case non_otp_dependencies(File) of
                [] ->
                    [];
                Missing ->
                    io:format("Missing the following applications: ~p - "
                              ++ "please add repos for them.~n",
                              [Missing]),
                    [ atom_to_list(M) || M <- Missing ]
            end
    end.


non_otp_dependencies(AppFile) ->
    {ok, [{application, _, Terms}]} = file:consult(AppFile),
    Apps = proplists:get_value(applications, Terms, []) ++
        proplists:get_value(included_applications, Terms, []),
    Apps -- otp_apps().


%% use
%% ls /usr/local/lib/erlang/lib/ | sed 's/\(.*\)-.*/\1,/'
%% to generate the list.
otp_apps() ->
    [appmon,
     asn1,
     common_test,
     compiler,
     cosEvent,
     cosEventDomain,
     cosFileTransfer,
     cosNotification,
     cosProperty,
     cosTime,
     cosTransactions,
     crypto,
     debugger,
     dialyzer,
     diameter,
     edoc,
     erl_docgen,
     erl_interface,
     erts,
     et,
     eunit,
     gs,
     hipe,
     ic,
     inets,
     inviso,
     jinterface,
     kernel,
     megaco,
     mnesia,
     observer,
     odbc,
     orber,
     os_mon,
     otp_mibs,
     parsetools,
     percept,
     pman,
     public_key,
     reltool,
     runtime_tools,
     sasl,
     snmp,
     ssh,
     ssl,
     stdlib,
     syntax_tools,
     test_server,
     toolbar,
     tools,
     tv,
     typer,
     webtool,
     wx,
     xmerl].
    
 

    
            
repo_map() ->
    Urls = config_repos(url),
    KVs = [ {repo_name(Url), Url} || Url <- Urls],
    orddict:from_list(KVs).
    
dependency_map() ->
    Urls = dependencies(url),
    KVs = [ {repo_name(Url), Url} || Url <- Urls],
    orddict:from_list(KVs).


    


