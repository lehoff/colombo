#!/usr/local/bin/escript
%%% -*- erlang -*-

-compile(export_all).

config_file() -> "./.colombo/config".

get_repo(RepoUrl) ->
    RepoName = repo_name(RepoUrl),
    case filelib:is_dir(RepoName) of
        false ->
            Cmd = io_lib:format("git clone ~s", [RepoUrl]),
            io:format("Executing: ~s~n", [Cmd]),
            os:cmd(Cmd);
        true ->
            Cwd = cd1(RepoName),
            Cmd = "git pull",
            io:format("Executing: ~s in ~s~n", [Cmd, Cwd ++ "/" ++ RepoName]),%%RepoName]),
            os:cmd(Cmd),
            ok = file:set_cwd(Cwd)
    end.

cd1(Dir) ->
    {ok, Cwd} = file:get_cwd(),
    SubDir = (Cwd ++ "/" ++ Dir),
    ok = file:set_cwd(SubDir),
    Cwd.




main(["show-config"]) ->
    ConfigFile = config_file(),
    case filelib:is_file(ConfigFile) of
        true ->
            {ok, Bin} = file:read_file(ConfigFile),
            io:format("~s~n", [Bin]);
        false ->
            io:format("No config created - use 'colombo init' to create one~n", [])
    end;
main(["init"]) ->
    ConfigFile = config_file(),
    filelib:ensure_dir(ConfigFile),
    %% @todo add checking for existing config file.
    {ok, File} = file:open(ConfigFile, [write]),
    ok = file:close(File);
main(["add-repo", "--force", Repo]) ->
    RepoName = repo_name(Repo),
    ok = delete_dir(RepoName),
    remove_repo_from_config(RepoName),
    main(["add-repo", Repo]);
main(["add-repo", Repo]) ->
    RepoMap = repo_map(),
    RepoName = repo_name(Repo),
    case lists:keyfind(RepoName, 1, RepoMap) of
        {RepoName, ExistingUrl} ->
            io:format("Application ~s is already added as ~s~n",
                      [RepoName, ExistingUrl]),
            io:format("Use 'add-repo --force' to overwrite.~n", []);
        false ->
            ConfigFile = config_file(),
            {ok, File} = file:open(ConfigFile, [append]),
            ok = append_repo(File, Repo),
            ok = file:close(File),
            io:format("Added ~s~n", [Repo])
    end;
main(["delete-repo", RepoName]) ->
    ok = delete_dir(RepoName),
    ok = remove_repo_from_config(RepoName),
    io:format("Removed ~s from config~n", [RepoName]);
main(["get-repos"]) ->
    Repos = config_repos(url),
    io:format("get-repos with Repos=~p~n", [Repos]),
    _ = [ get_repo(R)  || R <- Repos];
main(["rebar-deps", RebarConfig]) ->
    Repos = rebar_deps(RebarConfig),
    [ io:format("~s~n", [Repo]) || Repo <- Repos ];
main(["get-deps"]) ->
    io:format("preparing to resolve depedencies by doing 'get-repos'~n", []),
    main(["get-repos"]),
    DepMap = dependency_map(),
    RepoMap = repo_map(),
    Missing = orddict:fetch_keys(DepMap) -- orddict:fetch_keys(RepoMap),
    case Missing of
        [] ->
            ok;
        _ ->
            io:format("Missing: ~p~n", [Missing]),
            [ main(["add-repo", orddict:fetch(M, DepMap)])
              || M <- Missing ],
            main(["get-repos"]),
            main(["get-deps"])
    end;
main(["app-deps", RepoName]) ->
    case app_dependencies(RepoName) of
        [] ->
            io:format("~s has no dependencies.~n", [RepoName]);
        Repos ->
            DepNames =
                case [repo_name(Url) || {repo, Url} <- Repos] of
                    [] ->
                        Repos;
                    List ->
                        List
                end,
            DepStr = string:join(DepNames, ", "),
            io:format("~s depends on: ~s~n", [RepoName, DepStr])
    end;
main(["list-repos"]) ->
    RepoMap = repo_map(),
    io:format("colombo has the following repos in its configuration:~n", []),
    [ io:format("~s: ~s~n", [RepoName, RepoUrl])
      || {RepoName, RepoUrl} <- RepoMap].

append_repo(File, Repo) ->
    %% @todo rewrite this to use write_term_to_file
    file:write(File, io_lib:format("{repo, \"~s\"}.~n", [Repo])).

write_term_to_file(File, Term) ->
    file:write(File, io_lib:format("~p.~n", [Term])).

-spec config_repos('url'|'name') -> [string()].
config_repos(url) ->
    Terms = config_terms(),
    %%    io:format("config_repos Terms=~p~n", [Terms]),
    [R || {repo,R} <- Terms];
config_repos(name) ->
    Urls = config_repos(url),
    [ repo_name(Url) || Url <- Urls].

config_terms() ->
    ConfigFile = config_file(),
    {ok, Terms} = file:consult(ConfigFile),
    Terms.

rebar_deps(RebarConfig) ->
    {ok, Terms} = file:consult(RebarConfig),
%%    io:format("rebar_deps Terms=~p~n", [Terms]),
    RebarDeps = proplists:get_value(deps, Terms, []),
    [Repo || {_, _, {git, Repo, _}} <- RebarDeps].


repo_names() ->
    RepoUrls = config_repos(url),
    [ repo_name(RepoUrl) || RepoUrl <- RepoUrls].

repo_name(Url) ->
    Last = lists:last(string:tokens(Url, "/")),
    [RepoName | _ ] = string:tokens(Last, "."),
    RepoName.
    
-spec dependencies('url'|'name') -> [string()].
dependencies(url) ->
    RepoNames = repo_names(),
%%    io:format("RepoNames: ~p~n", [RepoNames]),
    Sorted =
        lists:sort(lists:flatten([app_dependencies(RepoName)
                                  || RepoName <- RepoNames])),
    [ Dep || {repo, Dep} <- Sorted ];
dependencies(name) ->
    Urls = dependencies(url),
    [ repo_name(Url) || Url <- Urls].

app_dependencies(RepoName) ->
    RepoPath = "./" ++ RepoName ++ "/",
    RebarConfig =   (RepoPath  ++ "rebar.config"),
    case filelib:is_file(RebarConfig) of
        true ->
            RebarDeps = rebar_deps(RebarConfig),
            [ {repo, D} || D <- RebarDeps ];
        false ->
            AppFile = (RepoPath ++ "ebin/" ++ RepoName ++ ".app"),
            AppSrcFile = (RepoPath ++ "src/" ++ RepoName ++ ".app.src"),
            File =
                case {filelib:is_file(AppFile), filelib:is_file(AppSrcFile)} of
                    {true, true} ->
                        io:format("ERROR: both .app and .app.src exists for ~s "
                                  ++ "- please resolve this~n",
                                  [RepoName]),
                        exit(two_app_files);
                    {true, false} ->
                        AppFile;
                    {false, true} ->
                        AppSrcFile;
                    {false, false} ->
                        io:format("ERROR: neither .app or .app.src exists for ~s "
                                  ++ "- please resolve this~n")
                end,
            Needs = non_otp_dependencies(File),
            NeedsStr = [ atom_to_list(A) || A <- Needs ],
            Missing = NeedsStr -- config_repos(name),
            case Missing of
                [] ->
                    [];
                _ ->
                    io:format("Missing the following applications: ~p - "
                              ++ "please add repos for them.~n",
                              [Missing]),
                    Missing
%%                    [ atom_to_list(M) || M <- Missing ]
            end
    end.

repo_map() ->
    Urls = config_repos(url),
    KVs = [ {repo_name(Url), Url} || Url <- Urls],
    orddict:from_list(KVs).
    
dependency_map() ->
    Urls = dependencies(url),
    KVs = [ {repo_name(Url), Url} || Url <- Urls],
    orddict:from_list(KVs).


non_otp_dependencies(AppFile) ->
    {ok, [{application, _, Terms}]} = file:consult(AppFile),
    Apps = proplists:get_value(applications, Terms, []) ++
        proplists:get_value(included_applications, Terms, []),
    Apps -- otp_apps().


delete_dir(Dir) ->
    case filelib:is_dir(Dir) of
        false ->
            ok;
        true ->
            Cwd = cd1(Dir),
            {ok, Contents} = file:list_dir("."),
            {Dirs, Files} = lists:partition( fun filelib:is_dir/1, Contents),
            _DeleteRes = [ file:delete(File) || File <- Files],
            [ delete_dir(D) || D <- Dirs],
            ok = file:set_cwd(Cwd),
            ok = file:del_dir(Dir),
            ok
    end.

remove_repo_from_config(RepoName) ->
    Terms = config_terms(),
%%    io:format("Existing config terms: ~p~n", [Terms]),
    NewTerms = lists:filter( fun(Term) -> not repo_spec_for_repo_name(Term, RepoName) end,
                             Terms),
%%    io:format("New config terms: ~p~n", [NewTerms]),
    ConfigFile = config_file(),
    {ok, File} = file:open(ConfigFile, [write]),
    lists:foreach( fun (Term) -> write_term_to_file(File, Term) end,
                   NewTerms),
    ok = file:close(File),
    %% AfterWrite = config_terms(),
    %% io:format("AfterWrite: ~p~n", [AfterWrite]),
    ok.


repo_spec_for_repo_name({repo, RepoUrl}, RepoName) ->
    repo_name(RepoUrl) == RepoName;
repo_spec_for_repo_name(_, _) ->
    false.

%% use
%% ls /usr/local/lib/erlang/lib/ | sed 's/\(.*\)-.*/\1,/'
%% to generate the list.
otp_apps() ->
    [appmon,
     asn1,
     common_test,
     compiler,
     cosEvent,
     cosEventDomain,
     cosFileTransfer,
     cosNotification,
     cosProperty,
     cosTime,
     cosTransactions,
     crypto,
     debugger,
     dialyzer,
     diameter,
     edoc,
     erl_docgen,
     erl_interface,
     erts,
     et,
     eunit,
     gs,
     hipe,
     ic,
     inets,
     inviso,
     jinterface,
     kernel,
     megaco,
     mnesia,
     observer,
     odbc,
     orber,
     os_mon,
     otp_mibs,
     parsetools,
     percept,
     pman,
     public_key,
     reltool,
     runtime_tools,
     sasl,
     snmp,
     ssh,
     ssl,
     stdlib,
     syntax_tools,
     test_server,
     toolbar,
     tools,
     tv,
     typer,
     webtool,
     wx,
     xmerl].
    
 

    
            


    


